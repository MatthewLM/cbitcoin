## This file generated by InlineX::C2XS (version 0.22) using Inline::C (version 0.5)
package CBitcoin::CBHD;

require Exporter;
*import = \&Exporter::import;
require DynaLoader;

$CBitcoin::CBHD::VERSION = '0.02';

DynaLoader::bootstrap CBitcoin::CBHD $CBitcoin::CBHD::VERSION;

@CBitcoin::CBHD::EXPORT = ();
@CBitcoin::CBHD::EXPORT_OK = ();

sub dl_load_flags {0} # Prevent DynaLoader from complaining and croaking


# Preloaded methods go here.


sub new {
	my $package = shift;
	return bless({}, $package);
}
# newMasterKey deriveChildPrivate exportWIFFromCBHDKey exportAddressFromCBHDKey publickeyFromWIF
# generate a key (parent)
sub generate {
	my $this = shift;
	eval{
		my $key = CBitcoin::CBHD::newMasterKey(1);
		$this->serializedkeypair($key) || die "Cannot load the key.";		
	};
	if($@){
		return 0;
	}
	return 1;
}

sub serializedkeypair {
	my $this = shift;
	my $x = shift;
	if($x){
		$this->{serializedkey} = $x;
		return $this->{serializedkey};
	}
	else{
		return $this->{serializedkey};
	}
}
=head2
---++ deriveChild($hardbool,$childid)
If you want to go from private parent keypair to public child keypair, then set $hardbool to false.  If you want to 
go from private parent keypair to private child keypair, then set $hardbool to true.

=cut
sub deriveChild {
	my $this = shift;
	my $hardbool = shift;
	my $childid = shift;
	my $childkey = new CBitcoin::CBHD;
	eval{
		if($hardbool){
			$hardbool = 1;
		}
		else{
			$hardbool = 0;
		}
		unless($childid > 0 && $childid < 2**31){
			die "The child id is not in the correct range.\n";
		}
		die "no private key" unless $this->serializedkeypair;
		$childkey->serializedkeypair(CBitcoin::CBHD::deriveChildPrivate($this->serializedkeypair(),$hardbool,$childid));
		
	};
	if($@){
		return undef;
	}
	return $childkey;
	
}

sub WIF {
	my $this = shift;
	my $wif = '';
	eval{
		die "no private key" unless $this->serializedkeypair();
		$wif = CBitcoin::CBHD::exportWIFFromCBHDKey($this->serializedkeypair());
	};
	if($@){
		return undef;
	}
	return $wif;
}

sub address {
	my $this = shift;
	my $address = '';
	eval{
		die "no private key" unless $this->serializedkeypair();
		$address = CBitcoin::CBHD::exportAddressFromCBHDKey($this->serializedkeypair());
	};
	if($@){
		return undef;
	}
	return $address;
}

sub publickey {
	my $this = shift;
	my $x = '';
	eval{
		die "no private key" unless $this->serializedkeypair();
		$x = CBitcoin::CBHD::exportPublicKeyFromCBHDKey($this->serializedkeypair());
	};
	if($@){
		return undef;
	}
	return $x;
}

1;
