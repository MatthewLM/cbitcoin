## This file generated by InlineX::C2XS (version 0.22) using Inline::C (version 0.5)
package CBitcoin::Transaction;

use bigint;
use CBitcoin::Script;
use CBitcoin::TransactionInput;
use CBitcoin::TransactionOutput;

require Exporter;
*import = \&Exporter::import;
require DynaLoader;

$CBitcoin::Transaction::VERSION = '0.01';

DynaLoader::bootstrap CBitcoin::Transaction $CBitcoin::Transaction::VERSION;

@CBitcoin::Transaction::EXPORT = ();
@CBitcoin::Transaction::EXPORT_OK = ();

sub dl_load_flags {0} # Prevent DynaLoader from complaining and croaking



=pod

---++ constructors

=cut

sub new {
	my $package = shift;
	my $this = bless({}, $package);
	$this->{inputs} = [];
	$this->{outputs} = [];
	my $x = shift;
	unless(ref($x) eq 'HASH'){
		return $this;
	}
	if(defined $x->{'data'}){
		# we have a tx input which is serialized
		$this->importSerializedData($x->{'data'});
		
	}
	else{
		# we have the data, let's get the serialized data
		$x->{'lockTime'} ||= 0;
		$x->{'version'} ||= 1;
		$this->lockTime($x->{'lockTime'});
		$this->version($x->{'version'});
	}
	
	
	return $this;
}
=pod

---++ variable accessors

=cut

sub lockTime {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	my $x = shift;
	if($x){
		# TODO: validation of some sort
		$this->{lockTime} = $x;
		return $x;
	}
	else{
		return $this->{lockTime};
	}	
}


sub version {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	my $x = shift;
	if($x){
		$this->{version} = $x;
		return $x;			
		

	}
	else{
		return $this->{version};
	}	
}

sub serializeddata {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	my $x = shift;
	if($x){
		# TODO
		$this->{serializeddata} = $x;
		return $x;
	}
	else{
		unless($this->{serializeddata}){
			eval{
				
			};
			if($@){
				warn "We cannot serialize the data yet.\n";
			}
		}
		return $this->{serializeddata};
	}	
}
# this serializes the data we have
sub serializeData {


	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	
	# check to see that we have inputs and outputs
	unless($this->numOfInputs() > 0 && $this->numOfOutputs() >  0){
		die "not enough inputs or outputs to serialize this transaction\n";
	}
	my @inputs;
	foreach my $inx (@{$this->{inputs}}){
		push(@inputs,$inx->serializeddata());	
	}
	my @outputs;
	foreach my $outx (@{$this->{outputs}}){
		push(@outputs,$outx->serializeddata());	
	}	
	# create_tx_obj(int lockTime, int version, SV* inputs, SV* outputs, int numOfInputs, int numOfOutputs)
	my $data = CBitcoin::Transaction::create_tx_obj(
		$this->lockTime()
		,$this->version()
		,\@inputs
		,\@outputs
		,$this->numOfInputs
		,$this->numOfOutputs
	);
	return $this->serializeddata($data);
	
}
# TODO: change the name of this function!!! it does the opposite of its name
sub deserializeData {

	use bigint;

	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';

	$this->serializeddata( 
		CBitcoin::Transaction::create_tx_obj( 
			$this->lockTime(), 
			$this->version()
		)
	);
	if(defined $this->serializeddata()){
		return 1;
	}
	else{
		return 0;
	}
}

# signatures....
=pod

---+++ sign($index,$cbhdkey)

Sign the ith ($index) output with the private key corresponding to the inputs.  The index starts from 0!!!!!

=cut

sub sign_single_input {

	use bigint;

	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	my ($index,$keypair) = (shift,shift);
	unless($index =~ m/\d+/){
		die "index is not a positive integer($index).\n";
	}
	unless(ref($keypair) eq 'CBitcoin::CBHD'){
		die "keypair is not a CBitcoin::CBHD object.\n";
	}

	unless($this->serializeddata()){
		die "serialize the tx data first, before trying to sign prevOuts.\n";
	}
	
	# get the input
	my $prevOutInput = $this->input($index);
	unless(ref($prevOutInput) eq 'CBitcoin::TransactionInput'){
		return undef;
	}
	
	
	# find out what type of script we are dealing with
	# 	p2sh, pubkey, keyhash, multisig
	my $scripttype = CBitcoin::Script::whatTypeOfScript($prevOutInput->script() );
	warn "My script:".$prevOutInput->script()."\n";
	my $data;
	if($scripttype eq 'keyhash'){
		$data = CBitcoin::Transaction::sign_tx_pubkeyhash(
			$this->serializeddata()
			,$keypair->serializedkeypair()
			,$prevOutInput->script()
			,$index
			,'CB_SIGHASH_ALL'
		);
	}
	elsif($scripttype eq 'multisig'){
		# do multisig 
		$data = CBitcoin::Transaction::sign_tx_multisig(
			$this->serializeddata()
			,$keypair->serializedkeypair()
			,$prevOutInput->script()
			,$index
			,'CB_SIGHASH_ALL'
		);
	}
	return $this->serializeddata($data) if $data;

	return $this->serializeddata();
}

=head2
---++ methods
=cut
sub addInput {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	my $x = shift;
	my $y;
	if(ref($x) eq 'HASH'){
		# we need script, prevOutHash, prevOutIndex
		if(
			$x->{'prevOutHash'}
			&& $x->{'prevOutIndex'}
			&& $x->{'script'}
		){
			$y = new CBitcoin::TransactionInput($x);	
		}
		else{
			die "hash has insufficient information for use in addTxInput\n";
		}
	}
	elsif(ref($x) eq 'CBitcoin::TransactionInput'){
		$y = $x;	
	}
	else{
		die "insufficient variables to use addTxInput function\n";
	}
	push(@{$this->{inputs}},$y);
	return scalar(@{$this->{inputs}});	
}

sub numOfInputs {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	return scalar(@{$this->{inputs}});	
}

sub input {
	my $this = shift;
	my $index = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	unless($index =~ m/\d+/ && $index >= 0 && $index < $this->numOfInputs() ){
		die "index is not an integer\n";
	}
	return $this->{inputs}->[$index];
}

sub addOutput {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	my $x = shift;
	my $y;
	if(ref($x) eq 'HASH'){
		# we need script, prevOutHash, prevOutIndex
		if(
			$x->{'value'}
			&& $x->{'script'}
		){
			$y = new CBitcoin::TransactionInput($x);	
		}
		else{
			die "hash has insufficient information for use in addOutput\n";
		}
	}
	elsif(ref($x) eq 'CBitcoin::TransactionOutput'){
		$y = $x;	
	}
	else{
		die "insufficient variables to use addOutput function\n";
	}
	push(@{$this->{outputs}},$y);
	return scalar(@{$this->{outputs}});	
}

sub numOfOutputs {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	return scalar(@{$this->{outputs}});	
}

sub output {
	my $this = shift;
	my $index = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	unless($index =~ m/\d+/ && $index >= 0 && $index < $this->numOfOutputs() ){
		die "index is not an integer\n";
	}
	return $this->{outputs}->[$index];
}

=head3
---+++ importSerializedData
Call this when you want the serialized data to be split up, parsed and assigned to other private variables.
=cut
sub importSerializedData {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	
	my $x = shift;
	
	if(
			$this->lockTime(CBitcoin::Transaction::get_lockTime_from_obj($x)	)
			&& $this->version(CBitcoin::Transaction::get_version_from_obj($x)  )
		){
		$this->{serializeddata} = $x;
		return 1;		
	}
	else{
		return undef;
	}
}

1;
