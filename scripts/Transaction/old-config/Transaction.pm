## This file generated by InlineX::C2XS (version 0.22) using Inline::C (version 0.5)
package CBitcoin::Transaction;

use CBitcoin::TransactionInput;

require Exporter;
*import = \&Exporter::import;
require DynaLoader;

$CBitcoin::Transaction::VERSION = '0.01';

DynaLoader::bootstrap CBitcoin::Transaction $CBitcoin::Transaction::VERSION;

@CBitcoin::Transaction::EXPORT = ();
@CBitcoin::Transaction::EXPORT_OK = ();

sub dl_load_flags {0} # Prevent DynaLoader from complaining and croaking

=head2
---++ constructors
=cut
sub new {
	my $package = shift;
	my $this = bless({}, $package);
	$this->{inputs} = [];
	$this->{outputs} = [];
	my $x = shift;
	unless(ref($x) eq 'HASH'){
		return $this;
	}
	if(defined $x->{'data'}){
		# we have a tx input which is serialized
		$this->importSerializedData($x->{'data'});
		
	}
	else{
		# we have the data, let's get the serialized data
		$x->{'lockTime'} ||= time(); # the time is not really relevant
		$x->{'version'} ||= 1;
		$this->lockTime($x->{'lockTime'});
		$this->version($x->{'version'});
	}
	
	
	return $this;
}
=head2
---++ variable accessors
=cut

sub lockTime {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	my $x = shift;
	if($x){
		# TODO: validation of some sort
		$this->{lockTime} = $x;
		return $x;
	}
	else{
		return $this->{lockTime};
	}	
}


sub version {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	my $x = shift;
	if($x){
		$this->{version} = $x;
		return $x;			
		

	}
	else{
		return $this->{version};
	}	
}

sub serializeddata {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	my $x = shift;
	if($x){
		# TODO
		$this->{serializeddata} = $x;
		return $x;
	}
	else{
		unless($this->{serializeddata}){
			eval{
				
			};
			if($@){
				warn "We cannot serialize the data yet.\n";
			}
		}
		return $this->{serializeddata};
	}	
}
# this serializes the data we have
sub serializeData {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	
	# check to see that we have inputs and outputs
	unless($this->numOfInputs() > 0 && $this->numOfOutputs() >  0){
		die "not enough inputs or outputs to serialize this transaction\n";
	}
	my @inputs;
	foreach my $inx (@{$this->{inputs}}){
		push(@inputs,$inx->serializeddata());	
	}
	my @outputs;
	foreach my $outx (@{$this->{outputs}}){
		push(@outputs,$outx->serializeddata());	
	}	
	# create_tx_obj(int lockTime, int version, SV* inputs, SV* outputs, int numOfInputs, int numOfOutputs)
	my $data = CBitcoin::Transaction::create_tx_obj(
		$this->lockTime()
		,$this->version()
		,\@inputs
		,\@outputs
		,$this->numOfInputs
		,$this->numOfOutputs
	);
	return $this->serializeddata($data);
	
}
sub deserializeData {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';

	$this->serializeddata( 
		CBitcoin::Transaction::create_tx_obj( 
			$this->lockTime(), 
			$this->version()
		)
	);
	if(defined $this->serializeddata()){
		return 1;
	}
	else{
		return 0;
	}
}

=head2
---++ methods
=cut
sub addInput {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	my $x = shift;
	my $y;
	if(ref($x) eq 'HASH'){
		# we need script, prevOutHash, prevOutIndex
		if(
			$x->{'prevOutHash'}
			&& $x->{'prevOutIndex'}
			&& $x->{'script'}
		){
			$y = new CBitcoin::TransactionInput($x);	
		}
		else{
			die "hash has insufficient information for use in addTxInput\n";
		}
	}
	elsif(ref($x) eq 'CBitcoin::TransactionInput'){
		$y = $x;	
	}
	else{
		die "insufficient variables to use addTxInput function\n";
	}
	push(@{$this->{inputs}},$y);
	return scalar(@{$this->{inputs}});	
}

sub numOfInputs {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	return scalar(@{$this->{inputs}});	
}


sub addOutput {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	my $x = shift;
	my $y;
	if(ref($x) eq 'HASH'){
		# we need script, prevOutHash, prevOutIndex
		if(
			$x->{'value'}
			&& $x->{'script'}
		){
			$y = new CBitcoin::TransactionInput($x);	
		}
		else{
			die "hash has insufficient information for use in addOutput\n";
		}
	}
	elsif(ref($x) eq 'CBitcoin::TransactionOutput'){
		$y = $x;	
	}
	else{
		die "insufficient variables to use addOutput function\n";
	}
	push(@{$this->{outputs}},$y);
	return scalar(@{$this->{outputs}});	
}

sub numOfOutputs {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	return scalar(@{$this->{outputs}});	
}
=head3
---+++ importSerializedData
Call this when you want the serialized data to be split up, parsed and assigned to other private variables.
=cut
sub importSerializedData {
	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	
	my $x = shift;
	
	if(
			$this->lockTime(CBitcoin::Transaction::get_lockTime_from_obj($x)	)
			&& $this->version(CBitcoin::Transaction::get_version_from_obj($x)  )
		){
		$this->{serializeddata} = $x;
		return 1;		
	}
	else{
		return undef;
	}
}

1;
