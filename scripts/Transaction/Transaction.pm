## This file generated by InlineX::C2XS (version 0.22) using Inline::C (version 0.5)
package CBitcoin::Transaction;

use bigint;
use CBitcoin::Script;
use CBitcoin::TransactionInput;
use CBitcoin::TransactionOutput;

require Exporter;
*import = \&Exporter::import;
require DynaLoader;

$CBitcoin::Transaction::VERSION = '0.01';

DynaLoader::bootstrap CBitcoin::Transaction $CBitcoin::Transaction::VERSION;

@CBitcoin::Transaction::EXPORT = ();
@CBitcoin::Transaction::EXPORT_OK = ();

sub dl_load_flags {0} # Prevent DynaLoader from complaining and croaking



=pod

---++ constructors

=cut

sub new {
	use bigint;
	my $package = shift;
	my $this = bless({}, $package);
	$this->{inputs} = [];
	$this->{outputs} = [];
	my $x = shift;
	unless(ref($x) eq 'HASH'){
		return $this;
	}
	if(defined $x->{'data'} && $x->{'data'} =~ m/^([0-9a-zA-Z]+)$/){
		# we have a tx input which is serialized
		$this->{'data'} = $x->{'data'};
		# test to see if the data is valid
	}
	elsif(
		defined $x->{'inputs'} && ref($x->{'inputs'}) eq 'ARRAY'
		&& defined $x->{'outputs'} && ref($x->{'outputs'}) eq 'ARRAY'
	){
		# we have the data, let's get the serialized data
		$x->{'lockTime'} ||= 0;
		$x->{'version'} ||= 1;
		my @inputs;
		foreach my $i1 (@{$x->{'inputs'}}){
			#warn "Input:".$i1->serialized_data."\n";
			push(@inputs,$i1->serialized_data);
		}
		my @outputs;
		foreach my $i1 (@{$x->{'outputs'}}){
			#warn "Output:".$i1->serialized_data."\n";
			push(@outputs,$i1->serialized_data);
		}
		# char* create_tx_obj(int lockTime, int version, SV* inputs, SV* outputs, int numOfInputs, int numOfOutputs){
		$this->{'data'} = create_tx_obj(
			$x->{'lockTime'}
			,$x->{'version'}
			,\@inputs
			,\@outputs
			,scalar(@inputs)
			,scalar(@outputs)
		);
		# make sure the data is properly formatted
		$this->lockTime();
		$this->version();
	}
	else{
		die "no arguments to create transaction";
	}
	
	
	return $this;
}
=pod

---++ variable accessors

=cut

sub serialized_data {
	my $this = shift;
	return $this->{'data'};
}

sub lockTime {
	my $this = shift;
	# this is a C function
	return get_lockTime_from_obj($this->{'data'});
}


sub version {
	my $this = shift;
	# this is a C function
	return get_version_from_obj($this->{'data'});
}

sub hash {
	my $this = shift;
	return hash_of_tx($this->{'data'});	
}


# signatures....
=pod

---+++ sign($index,$cbhdkey)

Sign the ith ($index) output with the private key corresponding to the inputs.  The index starts from 0!!!!!

=cut

sub sign_single_input {

	use bigint;

	my $this = shift;
	die "not correct Transaction type" unless ref($this) eq 'CBitcoin::Transaction';
	my ($index,$keypair) = (shift,shift);
	unless($index =~ m/\d+/){
		die "index is not a positive integer($index).\n";
	}
	unless(ref($keypair) eq 'CBitcoin::CBHD'){
		die "keypair is not a CBitcoin::CBHD object.\n";
	}

	unless($this->serializeddata()){
		die "serialize the tx data first, before trying to sign prevOuts.\n";
	}
	
	# get the input
	my $prevOutInput = $this->input($index);
	unless(ref($prevOutInput) eq 'CBitcoin::TransactionInput'){
		return undef;
	}
	
	
	# find out what type of script we are dealing with
	# 	p2sh, pubkey, keyhash, multisig
	my $scripttype = CBitcoin::Script::whatTypeOfScript($prevOutInput->script() );
	#warn "My script:".$prevOutInput->script()."\n";
	my $data;
	if($scripttype eq 'keyhash'){
		$data = CBitcoin::Transaction::sign_tx_pubkeyhash(
			$this->serializeddata()
			,$keypair->serializedkeypair()
			,$prevOutInput->script()
			,$index
			,'CB_SIGHASH_ALL'
		);
	}
	elsif($scripttype eq 'multisig'){
		# do multisig 
		$data = CBitcoin::Transaction::sign_tx_multisig(
			$this->serializeddata()
			,$keypair->serializedkeypair()
			,$prevOutInput->script()
			,$index
			,'CB_SIGHASH_ALL'
		);
	}
	return $this->serializeddata($data) if $data;

	return $this->serializeddata();
}

=pod

---++ methods

=cut

sub numOfInputs {
	my $this = shift;
	return get_numOfInputs($this->{'data'});	
}

sub input {
	my $this = shift;
	my $index = shift;
	unless($index =~ m/\d+/ && $index >= 0 && $index < $this->numOfInputs() ){
		die "index is not an integer or in the proper range\n";
	}
	# char* get_Input(char* serializedDataString,int InputIndex)
	return CBitcoin::TransactionInput->new({'data' => get_Input($this->{'data'},$index) });
}

sub numOfOutputs {
	my $this = shift;
	return get_numOfOutputs($this->{'data'});
}

sub output {
	my $this = shift;
	my $index = shift;
	unless($index =~ m/\d+/ && $index >= 0 && $index < $this->numOfOutputs() ){
		die "index is not an integer or in the proper range\n";
	}
	# char* get_Input(char* serializedDataString,int InputIndex)
	return CBitcoin::TransactionOutput->new({'data' => get_Output($this->{'data'},$index) });
}

1;
